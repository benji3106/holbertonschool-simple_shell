#include "shell.h"

/**
 * main - simple shell
 * @argc: nombre d'arguments passés au shell (non utilisé)
 * @argv: tableau d'arguments passés au shell (ex: "./shell")
 * @envp: variables d'environnement (HOME, PATH, USER...)
 *
 * Return: 0
 */
int main(int argc, char **argv, char **envp)
{
	/*
	 * VARIABLES POUR GETLINE
	 * line = pointeur vers le buffer (espace mémoire)
	 * 	 * len = taille du buffer alloué par getline
	 * 	 * n = nombre de caractères réellement lus par getline
	 */
	char *line = NULL;
	size_t len = 0;
	ssize_t n;

	/*
	 * VARIABLE POUR FORK
	 * pid = résultat de fork()
	 *       -1 = erreur
	 *        0 = je suis l'enfant
	 *       >0 = je suis le parent (pid = numéro de l'enfant)
	 * pid_t = type pour les Process ID
	 */
	pid_t pid;

	/*
	 * VARIABLE POUR EXECVE
	 * av = tableau d'arguments pour execve
	 *      av[0] = la commande (ex: "/bin/ls")
	 *      av[1] = NULL (fin du tableau)
	 */
	char *av[2];

	(void)argc;

	while (1)
	{
		/*
		 * ÉTAPE 1 : AFFICHER LE PROMPT
		 * printf affiche "$ " mais sans \n
		 * le texte reste dans le buffer d'affichage
		 */
		printf("$ ");

		/*
		 * ÉTAPE 2 : FORCER L'AFFICHAGE
		 * fflush vide le buffer d'affichage
		 * stdout = sortie standard (l'écran)
		 * Sans fflush, le prompt pourrait ne pas apparaître
		 */
		fflush(stdout);

		/*
		 * ÉTAPE 3 : LIRE LA COMMANDE
		 * getline lit une ligne depuis stdin (clavier)
		 *
		 * &line : adresse du pointeur line
		 *         getline va faire malloc et stocker l'adresse dans line
		 *         on passe & car getline doit MODIFIER line
		 *         (sans &, getline modifierait une copie)
		 *
		 * &len  : adresse de la taille du buffer
		 *         getline va mettre à jour len après malloc
		 *         on passe & car getline doit MODIFIER len
		 *
		 * stdin : d'où lire (le clavier)
		 *
		 * n     : retour de getline
		 *         = nombre de caractères lus (ex: 8 pour "/bin/ls\n")
		 *         = -1 si Ctrl+D ou erreur
		 *
		 * Comment getline fonctionne :
		 * 1. Si line == NULL, il fait malloc
		 * 2. Il lit caractère par caractère
		 * 3. Si buffer trop petit, il fait realloc
		 * 4. Il stocke les caractères dans le buffer
		 * 5. Il ajoute '\0' à la fin
		 * 6. Il retourne le nombre de caractères lus
		 */
		n = getline(&line, &len, stdin);

		if (n == -1)
		{
			printf("\n");
			free(line);
			exit(0);
		}

		line[n - 1] = '\0';	 /* Remplacer le \n par \0 */
		if (line[0] == '\0') /* Si l'utilisateur a appuyé sur Entrée */
			continue;		 /* on recommence la boucle */

		av[0] = line;
		av[1] = NULL;

		pid = fork();
		if (pid == -1)
		{
			perror("fork error");
			continue;
		}
		if (pid == 0)
		{
			if (execve(av[0], av, envp) == -1)
			{
				perror(argv[0]);
				exit(1);
			}
		}
		if (pid > 0)
		{
			wait(NULL);
		}
	}
	return (0);
}
